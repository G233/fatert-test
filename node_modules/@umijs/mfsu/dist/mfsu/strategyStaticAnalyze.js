var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/mfsu/strategyStaticAnalyze.ts
var strategyStaticAnalyze_exports = {};
__export(strategyStaticAnalyze_exports, {
  StaticAnalyzeStrategy: () => StaticAnalyzeStrategy
});
module.exports = __toCommonJS(strategyStaticAnalyze_exports);
var import_utils = require("@umijs/utils");
var import_checkMatch = require("../babelPlugins/awaitImport/checkMatch");
var import_MFImport = __toESM(require("../babelPlugins/awaitImport/MFImport"));
var import_staticDepInfo = require("../staticDepInfo/staticDepInfo");
var StaticAnalyzeStrategy = class {
  constructor({ mfsu, srcCodeCache }) {
    this.mfsu = mfsu;
    this.staticDepInfo = new import_staticDepInfo.StaticDepInfo({
      mfsu,
      srcCodeCache
    });
  }
  init() {
    this.staticDepInfo.init();
  }
  getDepModules() {
    return this.staticDepInfo.getDepModules();
  }
  getCacheFilePath() {
    return this.staticDepInfo.getCacheFilePath();
  }
  shouldBuild() {
    return this.staticDepInfo.shouldBuild();
  }
  writeCache() {
    this.staticDepInfo.writeCache();
  }
  getBabelPlugin() {
    return [import_MFImport.default, this.getMfImportOpts()];
  }
  getMfImportOpts() {
    const mfsu = this.mfsu;
    const mfsuOpts = this.mfsu.opts;
    const userUnMatches = mfsuOpts.unMatchLibs || [];
    const sharedUnMatches = Object.keys(mfsuOpts.shared || {});
    const remoteAliasUnMatches = (mfsuOpts.remoteAliases || []).map((str) => new RegExp(`^${str}`));
    const unMatches = [
      ...userUnMatches,
      ...sharedUnMatches,
      ...remoteAliasUnMatches
    ];
    return {
      resolveImportSource: (source) => {
        const match = (0, import_checkMatch.checkMatch)({
          value: source,
          filename: "_.js",
          opts: {
            exportAllMembers: mfsuOpts.exportAllMembers,
            unMatchLibs: unMatches,
            remoteName: mfsuOpts.mfName,
            alias: mfsu.alias,
            externals: mfsu.externals
          }
        });
        if (!match.isMatch) {
          return source;
        }
        const depMat = this.staticDepInfo.getDependencies();
        const m = depMat[match.value];
        if (m) {
          return m.replaceValue;
        }
        return match.value;
      },
      exportAllMembers: mfsuOpts.exportAllMembers,
      unMatchLibs: mfsuOpts.unMatchLibs,
      remoteName: mfsuOpts.mfName,
      alias: mfsu.alias,
      externals: mfsu.externals
    };
  }
  getBuildDepPlugConfig() {
    const mfsu = this.mfsu;
    return {
      beforeCompile: async () => {
        if (mfsu.depBuilder.isBuilding) {
          mfsu.buildDepsAgain = true;
        } else {
          import_utils.logger.event(`[MFSU][eager] start build deps`);
          this.staticDepInfo.consumeAllProducedEvents();
          mfsu.buildDeps().then(() => {
            mfsu.onProgress({
              done: true
            });
          }).catch((e) => {
            import_utils.printHelp.runtime(e);
            mfsu.onProgress({
              done: true
            });
          });
        }
      },
      onFileChange: async (c) => {
        import_utils.logger.debug("webpack found changes modified:", c.modifiedFiles, "removed:", c.removedFiles);
        if (!c.modifiedFiles || c.modifiedFiles.size === 0) {
          return;
        }
        if (!hasJSCodeFiles(c.modifiedFiles) && !hasJSCodeFiles(c.removedFiles)) {
          return;
        }
        const start = Date.now();
        let event = this.staticDepInfo.getProducedEvent();
        while (event.length === 0) {
          await sleep(100);
          event = this.staticDepInfo.getProducedEvent();
          if (Date.now() - start > 5e3) {
            import_utils.logger.warn("webpack wait mfsu deps too long");
            break;
          }
        }
        import_utils.logger.debug(`webpack waited ${Date.now() - start} ms`);
      },
      onCompileDone: () => {
      }
    };
  }
  loadCache() {
    this.staticDepInfo.loadCache();
  }
  refresh() {
    this.staticDepInfo.snapshot();
  }
};
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });
}
var REG_CODE_EXT = /\.(jsx|js|ts|tsx)$/;
function hasJSCodeFiles(files) {
  for (let file of files.values()) {
    if (REG_CODE_EXT.test(file)) {
      return true;
    }
  }
  return false;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  StaticAnalyzeStrategy
});
